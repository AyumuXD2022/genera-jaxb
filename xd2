package mx.com.backend.auth_service.components;

import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.MediaType;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.oauth2.core.OAuth2AuthenticationException;
import org.springframework.security.oauth2.core.OAuth2Error;
import org.springframework.security.oauth2.server.resource.BearerTokenError;
import org.springframework.security.oauth2.server.resource.web.BearerTokenAuthenticationEntryPoint;
import org.springframework.security.web.AuthenticationEntryPoint;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.time.LocalDateTime;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.UUID;

@Component
public class OAuth2AuthenticationEntryPoint implements AuthenticationEntryPoint {

    private static final Logger log = LoggerFactory.getLogger(OAuth2AuthenticationEntryPoint.class);

    private final ObjectMapper objectMapper = new ObjectMapper();

    private final BearerTokenAuthenticationEntryPoint delegate = new BearerTokenAuthenticationEntryPoint();

    @Override
    public void commence(HttpServletRequest request, HttpServletResponse response,
                         AuthenticationException authException) throws IOException, ServletException {

        log.error("üö´ OAuth2 Authentication Error: {} - Path: {}",
                authException.getMessage(), request.getRequestURI());

        // Primero delegamos en el entry point por defecto de OAuth2 para establecer el WWW-Authenticate header
        delegate.commence(request, response, authException);

        // Luego sobrescribimos la respuesta con nuestro formato JSON
        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        response.setCharacterEncoding("UTF-8");

        Map<String, Object> error = buildErrorResponse(request, authException);
        objectMapper.writeValue(response.getWriter(), error);
    }

    private Map<String, Object> buildErrorResponse(HttpServletRequest request, AuthenticationException authException) {
        String errorDescription = getErrorDescription(authException);
        String errorCode = getErrorCode(authException);

        Map<String, Object> error = new LinkedHashMap<>();
        error.put("message", "Acceso no autorizado");
        error.put("description", errorDescription);
        error.put("code", 401);
        error.put("error_code", errorCode);
        error.put("category", "Unauthorized");
        error.put("path", request.getRequestURI());
        error.put("timestamp", LocalDateTime.now().toString());
        error.put("action", getAction(authException));
        error.put("uuid", UUID.randomUUID().toString());
        error.put("severity", "ERROR");

        return error;
    }

    private String getErrorDescription(AuthenticationException authException) {
        // Verificar si es una OAuth2AuthenticationException con BearerTokenError
        if (authException instanceof OAuth2AuthenticationException oauth2Exception) {
            OAuth2Error error = oauth2Exception.getError();
            if (error instanceof BearerTokenError bearerTokenError) {
                return switch (bearerTokenError.getErrorCode()) {
                    case "invalid_token" -> "Token de acceso inv√°lido o malformado";
                    case "insufficient_scope" -> "El token no tiene los scopes requeridos";
                    case "invalid_request" -> "Solicitud de autenticaci√≥n inv√°lida";
                    default -> "Error de autenticaci√≥n OAuth2: " + bearerTokenError.getDescription();
                };
            }
        }

        // Verificar si el cause es un BearerTokenError (para compatibilidad)
        if (authException.getCause() instanceof OAuth2AuthenticationException oauth2Cause) {
            OAuth2Error error = oauth2Cause.getError();
            if (error instanceof BearerTokenError bearerTokenError) {
                return switch (bearerTokenError.getErrorCode()) {
                    case "invalid_token" -> "Token de acceso inv√°lido o malformado";
                    case "insufficient_scope" -> "El token no tiene los scopes requeridos";
                    case "invalid_request" -> "Solicitud de autenticaci√≥n inv√°lida";
                    default -> "Error de autenticaci√≥n OAuth2: " + bearerTokenError.getDescription();
                };
            }
        }

        String exceptionMessage = authException.getMessage();
        if (exceptionMessage.contains("expired")) {
            return "El token de acceso ha expirado";
        } else if (exceptionMessage.contains("signature")) {
            return "Firma del token inv√°lida";
        } else if (exceptionMessage.contains("malformed")) {
            return "Token malformado";
        }

        return "Error de autenticaci√≥n: " + authException.getMessage();
    }

    private String getErrorCode(AuthenticationException authException) {
        // Verificar si es una OAuth2AuthenticationException con BearerTokenError
        if (authException instanceof OAuth2AuthenticationException oauth2Exception) {
            OAuth2Error error = oauth2Exception.getError();
            if (error instanceof BearerTokenError bearerTokenError) {
                return bearerTokenError.getErrorCode();
            }
            return error.getErrorCode();
        }

        // Verificar si el cause es un OAuth2AuthenticationException
        if (authException.getCause() instanceof OAuth2AuthenticationException oauth2Cause) {
            OAuth2Error error = oauth2Cause.getError();
            if (error instanceof BearerTokenError bearerTokenError) {
                return bearerTokenError.getErrorCode();
            }
            return error.getErrorCode();
        }

        return "invalid_token";
    }

    private String getAction(AuthenticationException authException) {
        String errorCode = getErrorCode(authException);

        return switch (errorCode) {
            case "invalid_token", "expired" -> "refresh_token";
            case "insufficient_scope" -> "request_higher_privileges";
            case "invalid_request" -> "provide_valid_credentials";
            default -> "contact_support";
        };
    }
}




import java.sql.*;

public class TestAllConnectionOptions {
    public static void main(String[] args) {
        String usuario = "tu_usuario@DEV.XDV";
        String password = "tu_password";
        String baseDatos = "MiBaseDatos";
        
        // Todas las opciones posibles
        String[] urls = {
            // Opci√≥n 1: NTLM
            "jdbc:sqlserver://FMKLMVFVGL.DEV.XDV:1433;databaseName=" + baseDatos + ";integratedSecurity=true;authenticationScheme=NTLM;trustServerCertificate=true",
            
            // Opci√≥n 2: Usuario/Contrase√±a UPN
            "jdbc:sqlserver://FMKLMVFVGL.DEV.XDV:1433;databaseName=" + baseDatos + ";user=" + usuario + ";password=" + password + ";trustServerCertificate=true",
            
            // Opci√≥n 3: Usuario/Contrase√±a dominio\\usuario
            "jdbc:sqlserver://FMKLMVFVGL.DEV.XDV:1433;databaseName=" + baseDatos + ";user=DEV.XDV\\tu_usuario;password=" + password + ";trustServerCertificate=true",
            
            // Opci√≥n 4: Integrated Security sin scheme
            "jdbc:sqlserver://FMKLMVFVGL.DEV.XDV:1433;databaseName=" + baseDatos + ";integratedSecurity=true;trustServerCertificate=true",
            
            // Opci√≥n 5: Con instancia (si aplica)
            "jdbc:sqlserver://FMKLMVFVGL.DEV.XDV\\TEST:1433;databaseName=" + baseDatos + ";integratedSecurity=true;authenticationScheme=NTLM;trustServerCertificate=true",
            
            // Opci√≥n 6: Puerto diferente
            "jdbc:sqlserver://FMKLMVFVGL.DEV.XDV:64441;databaseName=" + baseDatos + ";integratedSecurity=true;authenticationScheme=NTLM;trustServerCertificate=true"
        };
        
        String[] descripciones = {
            "NTLM Authentication",
            "Usuario/Password (UPN)",
            "Usuario/Password (dominio\\usuario)", 
            "Integrated Security Auto",
            "Con Instancia TEST",
            "Puerto 64441"
        };
        
        for (int i = 0; i < urls.length; i++) {
            try {
                System.out.println("üîÑ Probando: " + descripciones[i]);
                
                Connection conn = DriverManager.getConnection(urls[i]);
                System.out.println("‚úÖ ¬°CONEXI√ìN EXITOSA!");
                
                // Verificar conexi√≥n
                Statement stmt = conn.createStatement();
                ResultSet rs = stmt.executeQuery(
                    "SELECT @@SERVERNAME as server, DB_NAME() as db, SUSER_NAME() as usuario"
                );
                
                if (rs.next()) {
                    System.out.println("   Servidor: " + rs.getString("server"));
                    System.out.println("   Base: " + rs.getString("db"));
                    System.out.println("   Usuario: " + rs.getString("usuario"));
                }
                
                rs.close();
                stmt.close();
                conn.close();
                
                System.out.println("üéØ USA ESTA URL: " + urls[i].split(";")[0]);
                break;
                
            } catch (SQLException e) {
                System.err.println("‚ùå Fall√≥: " + e.getMessage());
                if (e.getErrorCode() != 0) {
                    System.err.println("   C√≥digo error: " + e.getErrorCode());
                }
            }
            System.out.println("---");
        }
    }
}


// Verificar conectividad b√°sica
public class VerificarConectividad {
    public static void main(String[] args) {
        try {
            // Verificar si el servidor responde
            java.net.Socket socket = new java.net.Socket("FMKLMVFVGL.DEV.XDV", 1433);
            System.out.println("‚úÖ Servidor SQL responde en puerto 1433");
            socket.close();
        } catch (Exception e) {
            System.err.println("‚ùå No se puede conectar al servidor: " + e.getMessage());
        }
        
        // Probar puerto 64441 tambi√©n
        try {
            java.net.Socket socket = new java.net.Socket("FMKLMVFVGL.DEV.XDV", 64441);
            System.out.println("‚úÖ Servidor SQL responde en puerto 64441");
            socket.close();
        } catch (Exception e) {
            System.err.println("‚ùå No responde en puerto 64441: " + e.getMessage());
        }
    }
}


import java.sql.*;

public class TestWithKerberos {
    public static void main(String[] args) {
        
        // CONFIGURACI√ìN KERBEROS
        System.setProperty("java.security.krb5.conf", "C:/kerberos/krb5.conf");
        System.setProperty("javax.security.auth.useSubjectCredsOnly", "false");
        System.setProperty("sun.security.krb5.debug", "true"); // Para ver detalles
        
        String baseDatos = "MiBaseDatos";
        
        String[] urls = {
            // üîë OPCI√ìN KERBEROS 1: Kerberos expl√≠cito
            "jdbc:sqlserver://FMKLMVFVGL.DEV.XDV:1433;databaseName=" + baseDatos + ";integratedSecurity=true;authenticationScheme=JavaKerberos;trustServerCertificate=true",
            
            // üîë OPCI√ìN KERBEROS 2: Con instancia
            "jdbc:sqlserver://FMKLMVFVGL.DEV.XDV\\TEST:1433;databaseName=" + baseDatos + ";integratedSecurity=true;authenticationScheme=JavaKerberos;trustServerCertificate=true",
            
            // üîë OPCI√ìN KERBEROS 3: Puerto diferente
            "jdbc:sqlserver://FMKLMVFVGL.DEV.XDV:64441;databaseName=" + baseDatos + ";integratedSecurity=true;authenticationScheme=JavaKerberos;trustServerCertificate=true",
            
            // ‚ö†Ô∏è OPCI√ìN KERBEROS 4: Sin scheme (auto-detect)
            "jdbc:sqlserver://FMKLMVFVGL.DEV.XDV:1433;databaseName=" + baseDatos + ";integratedSecurity=true;trustServerCertificate=true"
        };
        
        String[] descripciones = {
            "Kerberos Expl√≠cito",
            "Kerberos con Instancia TEST", 
            "Kerberos Puerto 64441",
            "Kerberos Auto-Detect"
        };
        
        for (int i = 0; i < urls.length; i++) {
            try {
                System.out.println("üîë Probando KERBEROS: " + descripciones[i]);
                
                Connection conn = DriverManager.getConnection(urls[i]);
                System.out.println("‚úÖ ¬°CONEXI√ìN KERBEROS EXITOSA!");
                
                Statement stmt = conn.createStatement();
                ResultSet rs = stmt.executeQuery(
                    "SELECT @@SERVERNAME as server, DB_NAME() as db, SUSER_NAME() as usuario"
                );
                
                if (rs.next()) {
                    System.out.println("   Servidor: " + rs.getString("server"));
                    System.out.println("   Base: " + rs.getString("db"));
                    System.out.println("   Usuario: " + rs.getString("usuario"));
                }
                
                rs.close();
                stmt.close();
                conn.close();
                
                System.out.println("üéØ URL KERBEROS EXITOSA: " + urls[i].split(";")[0]);
                break;
                
            } catch (SQLException e) {
                System.err.println("‚ùå Kerberos fall√≥: " + e.getMessage());
                if (e.getErrorCode() != 0) {
                    System.err.println("   C√≥digo error: " + e.getErrorCode());
                }
            }
            System.out.println("---");
        }
    }
}
