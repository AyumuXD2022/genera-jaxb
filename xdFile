import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;
import java.time.format.ResolverStyle;
import java.util.Properties;

public class SecureMain {
    
    public static void main(String[] args) {
        String fechaValidada = null;
        String rutaValidada = null;
        
        try {
            // 1. Parsear argumentos sin validar (solo extraer)
            String fechaRaw = null;
            String rutaRaw = null;
            
            for (int i = 0; i < args.length; i++) {
                if ("-f".equals(args[i]) && i + 1 < args.length) {
                    fechaRaw = args[i + 1];
                    i++;
                } else if ("-p".equals(args[i]) && i + 1 < args.length) {
                    rutaRaw = args[i + 1];
                    i++;
                }
            }
            
            // 2. Validar que se recibieron los parámetros
            if (fechaRaw == null || rutaRaw == null) {
                throw new IllegalArgumentException("Faltan parámetros requeridos (-f y -p)");
            }
            
            // 3. Validar y sanitizar fecha - retorna String seguro
            fechaValidada = validarFecha(fechaRaw);
            
            // 4. Validar y sanitizar ruta - retorna String seguro (previene Path Traversal)
            rutaValidada = validarRuta(rutaRaw);
            
            // 5. Ahora es seguro usar los Strings validados
            System.out.println("✅ Fecha validada: " + fechaValidada);
            System.out.println("✅ Ruta validada: " + rutaValidada);
            
            // 6. Cargar properties de forma segura
            Properties props = cargarPropertiesSeguro(rutaValidada);
            System.out.println("✅ Properties cargadas: " + props.size() + " entradas");
            
            // 7. Tu lógica aquí usando los Strings validados
            procesarReporte(fechaValidada, rutaValidada, props);
            
        } catch (SecurityException e) {
            System.err.println("❌ Error de seguridad: " + e.getMessage());
            System.exit(1);
        } catch (IOException e) {
            System.err.println("❌ Error de I/O: " + e.getMessage());
            System.exit(1);
        } catch (IllegalArgumentException e) {
            System.err.println("❌ Error en argumentos: " + e.getMessage());
            mostrarUso();
            System.exit(1);
        }
    }
    
    /**
     * Valida fecha y retorna String validado
     */
    private static String validarFecha(String fecha) throws SecurityException {
        if (fecha == null || fecha.trim().isEmpty()) {
            throw new SecurityException("La fecha no puede estar vacía");
        }
        
        // 1. Sanitizar: remover espacios y limitar longitud
        fecha = fecha.trim();
        if (fecha.length() > 20) {
            throw new SecurityException("Fecha con formato inválido (muy larga)");
        }
        
        // 2. Validar caracteres permitidos
        if (!fecha.matches("^[0-9\\-/]+$")) {
            throw new SecurityException("La fecha contiene caracteres no permitidos");
        }
        
        // 3. Validar formato específico
        if (!fecha.matches("^\\d{4}-\\d{2}-\\d{2}$")) {
            throw new SecurityException("Formato de fecha inválido. Use: yyyy-MM-dd");
        }
        
        // 4. Parsear con validación estricta
        try {
            DateTimeFormatter formatter = DateTimeFormatter.ofPattern("uuuu-MM-dd")
                .withResolverStyle(ResolverStyle.STRICT);
            
            LocalDate fechaParsed = LocalDate.parse(fecha, formatter);
            
            // 5. Validar rango razonable
            LocalDate fechaMinima = LocalDate.of(2000, 1, 1);
            LocalDate fechaMaxima = LocalDate.now().plusYears(1);
            
            if (fechaParsed.isBefore(fechaMinima) || fechaParsed.isAfter(fechaMaxima)) {
                throw new SecurityException("Fecha fuera del rango permitido");
            }
            
            // 6. Retornar String validado en formato normalizado
            return fechaParsed.toString(); // yyyy-MM-dd
            
        } catch (DateTimeParseException e) {
            throw new SecurityException("Fecha inválida: " + e.getParsedString());
        }
    }
    
    /**
     * Valida ruta y retorna String validado - CRÍTICO PARA PREVENIR PATH TRAVERSAL
     */
    private static String validarRuta(String ruta) throws SecurityException {
        if (ruta == null || ruta.trim().isEmpty()) {
            throw new SecurityException("La ruta no puede estar vacía");
        }
        
        // 1. Limitar longitud (DoS prevention)
        if (ruta.length() > 500) {
            throw new SecurityException("Ruta demasiado larga");
        }
        
        // 2. CRÍTICO: Bloquear secuencias de Path Traversal
        if (ruta.contains("..") || ruta.contains("./") || ruta.contains("~")) {
            throw new SecurityException(
                "Ruta inválida: No se permiten referencias relativas (.. ./ ~)"
            );
        }
        
        // 3. Validar caracteres permitidos (whitelist)
        if (!ruta.matches("^[a-zA-Z0-9/_\\-\\.]+$")) {
            throw new SecurityException(
                "Ruta contiene caracteres no permitidos. Solo: [a-zA-Z0-9/_-.]"
            );
        }
        
        // 4. Normalizar ruta y obtener forma canónica
        try {
            File archivo = new File(ruta).getCanonicalFile();
            
            // 5. Bloquear rutas a directorios del sistema
            String rutaCanonica = archivo.getPath().toLowerCase();
            String[] rutasProhibidas = {
                "/etc/", "/passwd", "/shadow", "/root/", "/sys/", 
                "/proc/", "/boot/", "/dev/", "/var/log/",
                "c:\\windows\\", "c:\\program files", "c:\\users\\all users"
            };
            
            for (String prohibida : rutasProhibidas) {
                if (rutaCanonica.contains(prohibida)) {
                    throw new SecurityException(
                        "Acceso denegado: Directorio del sistema protegido"
                    );
                }
            }
            
            // 6. Verificar extensión permitida
            if (!archivo.getName().endsWith(".properties")) {
                throw new SecurityException(
                    "Solo archivos .properties permitidos"
                );
            }
            
            // 7. Verificar que existe y es archivo regular
            if (!archivo.exists()) {
                throw new SecurityException("El archivo no existe: " + archivo.getName());
            }
            
            if (!archivo.isFile()) {
                throw new SecurityException("La ruta no es un archivo regular");
            }
            
            // 8. Verificar permisos de lectura
            if (!archivo.canRead()) {
                throw new SecurityException("Sin permisos de lectura");
            }
            
            // 9. Verificar tamaño razonable (prevenir DoS)
            long maxSize = 10 * 1024 * 1024; // 10 MB
            if (archivo.length() > maxSize) {
                throw new SecurityException("Archivo muy grande (máx 10MB)");
            }
            
            // 10. Retornar String con ruta canónica validada
            return archivo.getPath();
            
        } catch (IOException e) {
            throw new SecurityException("Error al validar ruta: " + e.getMessage());
        }
    }
    
    /**
     * Carga properties de forma segura usando String validado
     */
    private static Properties cargarPropertiesSeguro(String rutaValidada) throws IOException {
        // rutaValidada ya fue sanitizada, es seguro usarla
        Properties props = new Properties();
        
        try (FileInputStream fis = new FileInputStream(rutaValidada)) {
            props.load(fis);
        }
        
        return props;
    }
    
    /**
     * Procesa el reporte usando Strings validados
     */
    private static void procesarReporte(String fechaValidada, String rutaValidada, Properties props) {
        System.out.println("\n=== PROCESANDO REPORTE ===");
        System.out.println("Fecha: " + fechaValidada);
        System.out.println("Ruta: " + rutaValidada);
        System.out.println("Configuración cargada desde properties");
        
        // Ejemplo de uso de los valores validados
        String servidor = props.getProperty("servidor", "localhost");
        String puerto = props.getProperty("puerto", "8080");
        
        System.out.println("Servidor: " + servidor);
        System.out.println("Puerto: " + puerto);
        
        // Tu lógica de negocio aquí...
        // Puedes usar fechaValidada y rutaValidada con seguridad
    }
    
    /**
     * Muestra información de uso
     */
    private static void mostrarUso() {
        System.err.println("\nUso:");
        System.err.println("  java app.jar -f <fecha> -p <ruta_properties>");
        System.err.println("\nEjemplo:");
        System.err.println("  java app.jar -f 2024-10-06 -p /app/config/dato.properties");
        System.err.println("\nFormatos:");
        System.err.println("  Fecha: yyyy-MM-dd (ej: 2024-10-06)");
        System.err.println("  Ruta:  Absoluta, solo archivos .properties");
    }
}
